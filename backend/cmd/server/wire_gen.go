// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/Wei-Shaw/sub2api/ent"
	"github.com/Wei-Shaw/sub2api/internal/config"
	"github.com/Wei-Shaw/sub2api/internal/handler"
	"github.com/Wei-Shaw/sub2api/internal/handler/admin"
	"github.com/Wei-Shaw/sub2api/internal/repository"
	"github.com/Wei-Shaw/sub2api/internal/server"
	"github.com/Wei-Shaw/sub2api/internal/server/middleware"
	"github.com/Wei-Shaw/sub2api/internal/service"
	"github.com/redis/go-redis/v9"
	"log"
	"net/http"
	"time"
)

import (
	_ "embed"
	_ "github.com/Wei-Shaw/sub2api/ent/runtime"
)

// Injectors from wire.go:

func initializeApplication(buildInfo handler.BuildInfo) (*Application, error) {
	configConfig, err := config.ProvideConfig()
	if err != nil {
		return nil, err
	}
	client, err := repository.ProvideEnt(configConfig)
	if err != nil {
		return nil, err
	}
	db, err := repository.ProvideSQLDB(client)
	if err != nil {
		return nil, err
	}
	userRepository := repository.NewUserRepository(client, db)
	redeemCodeRepository := repository.NewRedeemCodeRepository(client)
	redisClient := repository.ProvideRedis(configConfig)
	refreshTokenCache := repository.NewRefreshTokenCache(redisClient)
	settingRepository := repository.NewSettingRepository(client)
	settingService := service.NewSettingService(settingRepository, configConfig)
	emailCache := repository.NewEmailCache(redisClient)
	emailService := service.NewEmailService(settingRepository, emailCache)
	turnstileVerifier := repository.NewTurnstileVerifier()
	turnstileService := service.NewTurnstileService(settingService, turnstileVerifier)
	emailQueueService := service.ProvideEmailQueueService(emailService)
	promoCodeRepository := repository.NewPromoCodeRepository(client)
	billingCache := repository.NewBillingCache(redisClient)
	userSubscriptionRepository := repository.NewUserSubscriptionRepository(client)
	billingCacheService := service.NewBillingCacheService(billingCache, userRepository, userSubscriptionRepository, configConfig)
	apiKeyRepository := repository.NewAPIKeyRepository(client)
	groupRepository := repository.NewGroupRepository(client, db)
	userGroupRateRepository := repository.NewUserGroupRateRepository(db)
	apiKeyCache := repository.NewAPIKeyCache(redisClient)
	apiKeyService := service.NewAPIKeyService(apiKeyRepository, userRepository, groupRepository, userSubscriptionRepository, userGroupRateRepository, apiKeyCache, configConfig)
	apiKeyAuthCacheInvalidator := service.ProvideAPIKeyAuthCacheInvalidator(apiKeyService)
	promoService := service.NewPromoService(promoCodeRepository, userRepository, billingCacheService, client, apiKeyAuthCacheInvalidator)
	authService := service.NewAuthService(userRepository, redeemCodeRepository, refreshTokenCache, configConfig, settingService, emailService, turnstileService, emailQueueService, promoService)
	userService := service.NewUserService(userRepository, apiKeyAuthCacheInvalidator, billingCache)
	subscriptionService := service.NewSubscriptionService(groupRepository, userSubscriptionRepository, billingCacheService, client, configConfig)
	redeemCache := repository.NewRedeemCache(redisClient)
	redeemService := service.NewRedeemService(redeemCodeRepository, userRepository, subscriptionService, redeemCache, billingCacheService, client, apiKeyAuthCacheInvalidator)
	secretEncryptor, err := repository.NewAESEncryptor(configConfig)
	if err != nil {
		return nil, err
	}
	totpCache := repository.NewTotpCache(redisClient)
	totpService := service.NewTotpService(userRepository, secretEncryptor, totpCache, settingService, emailService, emailQueueService)
	authHandler := handler.NewAuthHandler(configConfig, authService, userService, settingService, promoService, redeemService, totpService)
	userHandler := handler.NewUserHandler(userService)
	apiKeyHandler := handler.NewAPIKeyHandler(apiKeyService)
	usageLogRepository := repository.NewUsageLogRepository(client, db)
	usageService := service.NewUsageService(usageLogRepository, userRepository, client, apiKeyAuthCacheInvalidator)
	usageHandler := handler.NewUsageHandler(usageService, apiKeyService)
	redeemHandler := handler.NewRedeemHandler(redeemService)
	subscriptionHandler := handler.NewSubscriptionHandler(subscriptionService)
	announcementRepository := repository.NewAnnouncementRepository(client)
	announcementReadRepository := repository.NewAnnouncementReadRepository(client)
	announcementService := service.NewAnnouncementService(announcementRepository, announcementReadRepository, userRepository, userSubscriptionRepository)
	announcementHandler := handler.NewAnnouncementHandler(announcementService)
	dashboardAggregationRepository := repository.NewDashboardAggregationRepository(db)
	dashboardStatsCache := repository.NewDashboardCache(redisClient, configConfig)
	dashboardService := service.NewDashboardService(usageLogRepository, dashboardAggregationRepository, dashboardStatsCache, configConfig)
	timingWheelService, err := service.ProvideTimingWheelService()
	if err != nil {
		return nil, err
	}
	dashboardAggregationService := service.ProvideDashboardAggregationService(dashboardAggregationRepository, timingWheelService, configConfig)
	dashboardHandler := admin.NewDashboardHandler(dashboardService, dashboardAggregationService)
	schedulerCache := repository.NewSchedulerCache(redisClient)
	accountRepository := repository.NewAccountRepository(client, db, schedulerCache)
	soraAccountRepository := repository.NewSoraAccountRepository(db)
	proxyRepository := repository.NewProxyRepository(client, db)
	proxyExitInfoProber := repository.NewProxyExitInfoProber(configConfig)
	proxyLatencyCache := repository.NewProxyLatencyCache(redisClient)
	adminService := service.NewAdminService(userRepository, groupRepository, accountRepository, soraAccountRepository, proxyRepository, apiKeyRepository, redeemCodeRepository, userGroupRateRepository, billingCacheService, proxyExitInfoProber, proxyLatencyCache, apiKeyAuthCacheInvalidator)
	concurrencyCache := repository.ProvideConcurrencyCache(redisClient, configConfig)
	concurrencyService := service.ProvideConcurrencyService(concurrencyCache, accountRepository, configConfig)
	adminUserHandler := admin.NewUserHandler(adminService, concurrencyService)
	groupHandler := admin.NewGroupHandler(adminService)
	claudeOAuthClient := repository.NewClaudeOAuthClient()
	oAuthService := service.NewOAuthService(proxyRepository, claudeOAuthClient)
	openAIOAuthClient := repository.NewOpenAIOAuthClient()
	openAIOAuthService := service.NewOpenAIOAuthService(proxyRepository, openAIOAuthClient)
	geminiOAuthClient := repository.NewGeminiOAuthClient(configConfig)
	geminiCliCodeAssistClient := repository.NewGeminiCliCodeAssistClient()
	geminiOAuthService := service.NewGeminiOAuthService(proxyRepository, geminiOAuthClient, geminiCliCodeAssistClient, configConfig)
	antigravityOAuthService := service.NewAntigravityOAuthService(proxyRepository)
	geminiQuotaService := service.NewGeminiQuotaService(configConfig, settingRepository)
	tempUnschedCache := repository.NewTempUnschedCache(redisClient)
	timeoutCounterCache := repository.NewTimeoutCounterCache(redisClient)
	geminiTokenCache := repository.NewGeminiTokenCache(redisClient)
	compositeTokenCacheInvalidator := service.NewCompositeTokenCacheInvalidator(geminiTokenCache)
	rateLimitService := service.ProvideRateLimitService(accountRepository, usageLogRepository, configConfig, geminiQuotaService, tempUnschedCache, timeoutCounterCache, settingService, compositeTokenCacheInvalidator)
	httpUpstream := repository.NewHTTPUpstream(configConfig)
	claudeUsageFetcher := repository.NewClaudeUsageFetcher(httpUpstream)
	antigravityQuotaFetcher := service.NewAntigravityQuotaFetcher(proxyRepository)
	usageCache := service.NewUsageCache()
	identityCache := repository.NewIdentityCache(redisClient)
	accountUsageService := service.NewAccountUsageService(accountRepository, usageLogRepository, claudeUsageFetcher, geminiQuotaService, antigravityQuotaFetcher, usageCache, identityCache)
	geminiTokenProvider := service.NewGeminiTokenProvider(accountRepository, geminiTokenCache, geminiOAuthService)
	gatewayCache := repository.NewGatewayCache(redisClient)
	schedulerOutboxRepository := repository.NewSchedulerOutboxRepository(db)
	schedulerSnapshotService := service.ProvideSchedulerSnapshotService(schedulerCache, schedulerOutboxRepository, accountRepository, groupRepository, configConfig)
	antigravityTokenProvider := service.NewAntigravityTokenProvider(accountRepository, geminiTokenCache, antigravityOAuthService)
	antigravityGatewayService := service.NewAntigravityGatewayService(accountRepository, gatewayCache, schedulerSnapshotService, antigravityTokenProvider, rateLimitService, httpUpstream, settingService)
	accountTestService := service.NewAccountTestService(accountRepository, geminiTokenProvider, antigravityGatewayService, httpUpstream, configConfig)
	crsSyncService := service.NewCRSSyncService(accountRepository, proxyRepository, oAuthService, openAIOAuthService, geminiOAuthService, configConfig)
	sessionLimitCache := repository.ProvideSessionLimitCache(redisClient, configConfig)
	accountHandler := admin.NewAccountHandler(adminService, oAuthService, openAIOAuthService, geminiOAuthService, antigravityOAuthService, rateLimitService, accountUsageService, accountTestService, concurrencyService, crsSyncService, sessionLimitCache, compositeTokenCacheInvalidator)
	adminAnnouncementHandler := admin.NewAnnouncementHandler(announcementService)
	oAuthHandler := admin.NewOAuthHandler(oAuthService)
	openAIOAuthHandler := admin.NewOpenAIOAuthHandler(openAIOAuthService, adminService)
	geminiOAuthHandler := admin.NewGeminiOAuthHandler(geminiOAuthService)
	antigravityOAuthHandler := admin.NewAntigravityOAuthHandler(antigravityOAuthService)
	proxyHandler := admin.NewProxyHandler(adminService)
	adminRedeemHandler := admin.NewRedeemHandler(adminService)
	promoHandler := admin.NewPromoHandler(promoService)
	opsRepository := repository.NewOpsRepository(db)
	pricingRemoteClient := repository.ProvidePricingRemoteClient(configConfig)
	pricingService, err := service.ProvidePricingService(configConfig, pricingRemoteClient)
	if err != nil {
		return nil, err
	}
	billingService := service.NewBillingService(configConfig, pricingService)
	identityService := service.NewIdentityService(identityCache)
	deferredService := service.ProvideDeferredService(accountRepository, timingWheelService)
	claudeTokenProvider := service.NewClaudeTokenProvider(accountRepository, geminiTokenCache, oAuthService)
	digestSessionStore := service.NewDigestSessionStore()
	gatewayService := service.NewGatewayService(accountRepository, groupRepository, usageLogRepository, userRepository, userSubscriptionRepository, userGroupRateRepository, gatewayCache, configConfig, schedulerSnapshotService, concurrencyService, billingService, rateLimitService, billingCacheService, identityService, httpUpstream, deferredService, claudeTokenProvider, sessionLimitCache, digestSessionStore)
	openAITokenProvider := service.NewOpenAITokenProvider(accountRepository, geminiTokenCache, openAIOAuthService)
	openAIGatewayService := service.NewOpenAIGatewayService(accountRepository, usageLogRepository, userRepository, userSubscriptionRepository, gatewayCache, configConfig, schedulerSnapshotService, concurrencyService, billingService, rateLimitService, billingCacheService, httpUpstream, deferredService, openAITokenProvider)
	geminiMessagesCompatService := service.NewGeminiMessagesCompatService(accountRepository, groupRepository, gatewayCache, schedulerSnapshotService, geminiTokenProvider, rateLimitService, httpUpstream, antigravityGatewayService, configConfig)
	opsSystemLogSink := service.ProvideOpsSystemLogSink(opsRepository)
	opsService := service.NewOpsService(opsRepository, settingRepository, configConfig, accountRepository, userRepository, concurrencyService, gatewayService, openAIGatewayService, geminiMessagesCompatService, antigravityGatewayService, opsSystemLogSink)
	settingHandler := admin.NewSettingHandler(settingService, emailService, turnstileService, opsService)
	opsHandler := admin.NewOpsHandler(opsService)
	updateCache := repository.NewUpdateCache(redisClient)
	gitHubReleaseClient := repository.ProvideGitHubReleaseClient(configConfig)
	serviceBuildInfo := provideServiceBuildInfo(buildInfo)
	updateService := service.ProvideUpdateService(updateCache, gitHubReleaseClient, serviceBuildInfo)
	idempotencyRepository := repository.NewIdempotencyRepository(client, db)
	systemOperationLockService := service.ProvideSystemOperationLockService(idempotencyRepository, configConfig)
	systemHandler := handler.ProvideSystemHandler(updateService, systemOperationLockService)
	adminSubscriptionHandler := admin.NewSubscriptionHandler(subscriptionService)
	usageCleanupRepository := repository.NewUsageCleanupRepository(client, db)
	usageCleanupService := service.ProvideUsageCleanupService(usageCleanupRepository, timingWheelService, dashboardAggregationService, configConfig)
	adminUsageHandler := admin.NewUsageHandler(usageService, apiKeyService, adminService, usageCleanupService)
	userAttributeDefinitionRepository := repository.NewUserAttributeDefinitionRepository(client)
	userAttributeValueRepository := repository.NewUserAttributeValueRepository(client)
	userAttributeService := service.NewUserAttributeService(userAttributeDefinitionRepository, userAttributeValueRepository)
	userAttributeHandler := admin.NewUserAttributeHandler(userAttributeService)
	errorPassthroughRepository := repository.NewErrorPassthroughRepository(client)
	errorPassthroughCache := repository.NewErrorPassthroughCache(redisClient)
	errorPassthroughService := service.NewErrorPassthroughService(errorPassthroughRepository, errorPassthroughCache)
	errorPassthroughHandler := admin.NewErrorPassthroughHandler(errorPassthroughService)
	adminHandlers := handler.ProvideAdminHandlers(dashboardHandler, adminUserHandler, groupHandler, accountHandler, adminAnnouncementHandler, oAuthHandler, openAIOAuthHandler, geminiOAuthHandler, antigravityOAuthHandler, proxyHandler, adminRedeemHandler, promoHandler, settingHandler, opsHandler, systemHandler, adminSubscriptionHandler, adminUsageHandler, userAttributeHandler, errorPassthroughHandler)
	usageRecordWorkerPool := service.NewUsageRecordWorkerPool(configConfig)
	gatewayHandler := handler.NewGatewayHandler(gatewayService, geminiMessagesCompatService, antigravityGatewayService, userService, concurrencyService, billingCacheService, usageService, apiKeyService, usageRecordWorkerPool, errorPassthroughService, configConfig)
	openAIGatewayHandler := handler.NewOpenAIGatewayHandler(openAIGatewayService, concurrencyService, billingCacheService, apiKeyService, usageRecordWorkerPool, errorPassthroughService, configConfig)
	soraDirectClient := service.ProvideSoraDirectClient(configConfig, httpUpstream, openAITokenProvider, accountRepository, soraAccountRepository)
	soraMediaStorage := service.ProvideSoraMediaStorage(configConfig)
	soraGatewayService := service.NewSoraGatewayService(soraDirectClient, soraMediaStorage, rateLimitService, configConfig)
	soraGatewayHandler := handler.NewSoraGatewayHandler(gatewayService, soraGatewayService, concurrencyService, billingCacheService, usageRecordWorkerPool, configConfig)
	handlerSettingHandler := handler.ProvideSettingHandler(settingService, buildInfo)
	totpHandler := handler.NewTotpHandler(totpService)
	idempotencyCoordinator := service.ProvideIdempotencyCoordinator(idempotencyRepository, configConfig)
	idempotencyCleanupService := service.ProvideIdempotencyCleanupService(idempotencyRepository, configConfig)
	handlers := handler.ProvideHandlers(authHandler, userHandler, apiKeyHandler, usageHandler, redeemHandler, subscriptionHandler, announcementHandler, adminHandlers, gatewayHandler, openAIGatewayHandler, soraGatewayHandler, handlerSettingHandler, totpHandler, idempotencyCoordinator, idempotencyCleanupService)
	jwtAuthMiddleware := middleware.NewJWTAuthMiddleware(authService, userService)
	adminAuthMiddleware := middleware.NewAdminAuthMiddleware(authService, userService, settingService)
	apiKeyAuthMiddleware := middleware.NewAPIKeyAuthMiddleware(apiKeyService, subscriptionService, configConfig)
	engine := server.ProvideRouter(configConfig, handlers, jwtAuthMiddleware, adminAuthMiddleware, apiKeyAuthMiddleware, apiKeyService, subscriptionService, opsService, settingService, redisClient)
	httpServer := server.ProvideHTTPServer(configConfig, engine)
	opsMetricsCollector := service.ProvideOpsMetricsCollector(opsRepository, settingRepository, accountRepository, concurrencyService, db, redisClient, configConfig)
	opsAggregationService := service.ProvideOpsAggregationService(opsRepository, settingRepository, db, redisClient, configConfig)
	opsAlertEvaluatorService := service.ProvideOpsAlertEvaluatorService(opsService, opsRepository, emailService, redisClient, configConfig)
	opsCleanupService := service.ProvideOpsCleanupService(opsRepository, db, redisClient, configConfig)
	opsScheduledReportService := service.ProvideOpsScheduledReportService(opsService, userService, emailService, redisClient, configConfig)
	soraMediaCleanupService := service.ProvideSoraMediaCleanupService(soraMediaStorage, configConfig)
	tokenRefreshService := service.ProvideTokenRefreshService(accountRepository, soraAccountRepository, oAuthService, openAIOAuthService, geminiOAuthService, antigravityOAuthService, compositeTokenCacheInvalidator, schedulerCache, configConfig)
	accountExpiryService := service.ProvideAccountExpiryService(accountRepository)
	subscriptionExpiryService := service.ProvideSubscriptionExpiryService(userSubscriptionRepository)
	v := provideCleanup(client, redisClient, opsMetricsCollector, opsAggregationService, opsAlertEvaluatorService, opsCleanupService, opsScheduledReportService, opsSystemLogSink, soraMediaCleanupService, schedulerSnapshotService, tokenRefreshService, accountExpiryService, subscriptionExpiryService, usageCleanupService, idempotencyCleanupService, pricingService, emailQueueService, billingCacheService, usageRecordWorkerPool, subscriptionService, oAuthService, openAIOAuthService, geminiOAuthService, antigravityOAuthService)
	application := &Application{
		Server:  httpServer,
		Cleanup: v,
	}
	return application, nil
}

// wire.go:

type Application struct {
	Server  *http.Server
	Cleanup func()
}

func provideServiceBuildInfo(buildInfo handler.BuildInfo) service.BuildInfo {
	return service.BuildInfo{
		Version:   buildInfo.Version,
		BuildType: buildInfo.BuildType,
	}
}

func provideCleanup(
	entClient *ent.Client,
	rdb *redis.Client,
	opsMetricsCollector *service.OpsMetricsCollector,
	opsAggregation *service.OpsAggregationService,
	opsAlertEvaluator *service.OpsAlertEvaluatorService,
	opsCleanup *service.OpsCleanupService,
	opsScheduledReport *service.OpsScheduledReportService,
	opsSystemLogSink *service.OpsSystemLogSink,
	soraMediaCleanup *service.SoraMediaCleanupService,
	schedulerSnapshot *service.SchedulerSnapshotService,
	tokenRefresh *service.TokenRefreshService,
	accountExpiry *service.AccountExpiryService,
	subscriptionExpiry *service.SubscriptionExpiryService,
	usageCleanup *service.UsageCleanupService,
	idempotencyCleanup *service.IdempotencyCleanupService,
	pricing *service.PricingService,
	emailQueue *service.EmailQueueService,
	billingCache *service.BillingCacheService,
	usageRecordWorkerPool *service.UsageRecordWorkerPool,
	subscriptionService *service.SubscriptionService,
	oauth *service.OAuthService,
	openaiOAuth *service.OpenAIOAuthService,
	geminiOAuth *service.GeminiOAuthService,
	antigravityOAuth *service.AntigravityOAuthService,
) func() {
	return func() {
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		cleanupSteps := []struct {
			name string
			fn   func() error
		}{
			{"OpsScheduledReportService", func() error {
				if opsScheduledReport != nil {
					opsScheduledReport.Stop()
				}
				return nil
			}},
			{"OpsCleanupService", func() error {
				if opsCleanup != nil {
					opsCleanup.Stop()
				}
				return nil
			}},
			{"OpsSystemLogSink", func() error {
				if opsSystemLogSink != nil {
					opsSystemLogSink.Stop()
				}
				return nil
			}},
			{"SoraMediaCleanupService", func() error {
				if soraMediaCleanup != nil {
					soraMediaCleanup.Stop()
				}
				return nil
			}},
			{"OpsAlertEvaluatorService", func() error {
				if opsAlertEvaluator != nil {
					opsAlertEvaluator.Stop()
				}
				return nil
			}},
			{"OpsAggregationService", func() error {
				if opsAggregation != nil {
					opsAggregation.Stop()
				}
				return nil
			}},
			{"OpsMetricsCollector", func() error {
				if opsMetricsCollector != nil {
					opsMetricsCollector.Stop()
				}
				return nil
			}},
			{"SchedulerSnapshotService", func() error {
				if schedulerSnapshot != nil {
					schedulerSnapshot.Stop()
				}
				return nil
			}},
			{"UsageCleanupService", func() error {
				if usageCleanup != nil {
					usageCleanup.Stop()
				}
				return nil
			}},
			{"IdempotencyCleanupService", func() error {
				if idempotencyCleanup != nil {
					idempotencyCleanup.Stop()
				}
				return nil
			}},
			{"TokenRefreshService", func() error {
				tokenRefresh.Stop()
				return nil
			}},
			{"AccountExpiryService", func() error {
				accountExpiry.Stop()
				return nil
			}},
			{"SubscriptionExpiryService", func() error {
				subscriptionExpiry.Stop()
				return nil
			}},
			{"SubscriptionService", func() error {
				if subscriptionService != nil {
					subscriptionService.Stop()
				}
				return nil
			}},
			{"PricingService", func() error {
				pricing.Stop()
				return nil
			}},
			{"EmailQueueService", func() error {
				emailQueue.Stop()
				return nil
			}},
			{"BillingCacheService", func() error {
				billingCache.Stop()
				return nil
			}},
			{"UsageRecordWorkerPool", func() error {
				if usageRecordWorkerPool != nil {
					usageRecordWorkerPool.Stop()
				}
				return nil
			}},
			{"OAuthService", func() error {
				oauth.Stop()
				return nil
			}},
			{"OpenAIOAuthService", func() error {
				openaiOAuth.Stop()
				return nil
			}},
			{"GeminiOAuthService", func() error {
				geminiOAuth.Stop()
				return nil
			}},
			{"AntigravityOAuthService", func() error {
				antigravityOAuth.Stop()
				return nil
			}},
			{"Redis", func() error {
				return rdb.Close()
			}},
			{"Ent", func() error {
				return entClient.Close()
			}},
		}

		for _, step := range cleanupSteps {
			if err := step.fn(); err != nil {
				log.Printf("[Cleanup] %s failed: %v", step.name, err)

			} else {
				log.Printf("[Cleanup] %s succeeded", step.name)
			}
		}

		select {
		case <-ctx.Done():
			log.Printf("[Cleanup] Warning: cleanup timed out after 10 seconds")
		default:
			log.Printf("[Cleanup] All cleanup steps completed")
		}
	}
}
